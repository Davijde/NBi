<?xml version="1.0" encoding="utf-8" ?>
<testSuite name="Acceptance Testing: ResultSet" xmlns="http://NBi/TestSuite">
  <settings>
    <default apply-to="system-under-test">
      <connectionString>Data Source=mhknbn2kdz.database.windows.net;Initial Catalog=AdventureWorks2012;User Id=sqlfamily;password=sqlf@m1ly</connectionString>
    </default>
    <default apply-to="assert">
      <connectionString>Data Source=mhknbn2kdz.database.windows.net;Initial Catalog=AdventureWorks2012;User Id=sqlfamily;password=sqlf@m1ly</connectionString>
    </default>
    <default apply-to="variable">
      <connectionString>Data Source=mhknbn2kdz.database.windows.net;Initial Catalog=AdventureWorks2012;User Id=sqlfamily;password=sqlf@m1ly</connectionString>
    </default>
    <reference name="ref1">
      <connectionString>Data Source=mhknbn2kdz.database.windows.net;Initial Catalog=AdventureWorks2012;User Id=sqlfamily;password=sqlf@m1ly</connectionString>
    </reference>
  </settings>
  <variables>
    <variable name="var1">
      <query-scalar>select 1963</query-scalar>
    </variable>
    <variable name="CY2007">
      <script language="c-sharp">"CY 2007"</script>
    </variable>
    <variable name="year">
      <script language="c-sharp">new DateTime(2006, 1, 1)</script>
    </variable>
    <variable name="length">
      <script language="c-sharp">2+1</script>
    </variable>
  </variables>
  <group name="asserts">
    <test name="Csv equal to embedded result-set" uid="0001">
      <system-under-test>
        <resultSet file="..\Csv\ResellerOrderCountByYearBefore2006.csv"/>
      </system-under-test>
      <assert>
        <equalTo>
          <resultSet>
            <row>
              <cell>CY 2005</cell>
              <cell>366</cell>
            </row>
            <row>
              <cell>CY 2006</cell>
              <cell>1015</cell>
            </row>
            <row>
              <cell>CY 2007</cell>
              <cell>1521</cell>
            </row>
            <row>
              <cell>CY 2008</cell>
              <cell>894</cell>
            </row>
          </resultSet>
        </equalTo>
      </assert>
    </test>
    <test name="Csv equivalent to embedded result-set" uid="0002">
      <system-under-test>
        <resultSet file="..\Csv\ResellerOrderCountByYearBefore2006.csv"/>
      </system-under-test>
      <assert>
        <intersection-of>
          <resultSet>
            <row>
              <cell>CY 2008</cell>
              <cell>894</cell>
            </row>
            <row>
              <cell>CY 2009</cell>
              <cell>1800</cell>
            </row>
          </resultSet>
        </intersection-of>
      </assert>
    </test>
    <test name="all are less than 10000" uid="0020">
      <system-under-test>
        <resultSet file="..\Csv\ResellerOrderCountByYearBefore2006.csv"/>
      </system-under-test>
      <assert>
        <all-rows>
          <predicate name="#1">
            <less-than>10000</less-than>
          </predicate>
        </all-rows>
      </assert>
    </test>
    <test name="none are more than 10000" uid="0030">
      <system-under-test>
        <resultSet file="..\Csv\ResellerOrderCountByYearBefore2006.csv"/>
      </system-under-test>
      <assert>
        <no-rows>
          <predicate name="#1">
            <more-than>10000</more-than>
          </predicate>
        </no-rows>
      </assert>
    </test>
    <test name="some are less than 1000" uid="0040">
      <system-under-test>
        <resultSet file="..\Csv\ResellerOrderCountByYearBefore2006.csv"/>
      </system-under-test>
      <assert>
        <some-rows>
          <predicate name="#1">
            <less-than>1000</less-than>
          </predicate>
        </some-rows>
      </assert>
    </test>
    <test name="single is more than 1500" uid="0050">
      <system-under-test>
        <resultSet file="..\Csv\ResellerOrderCountByYearBefore2006.csv"/>
      </system-under-test>
      <assert>
        <single-row>
          <predicate name="#1">
            <more-than>1500</more-than>
          </predicate>
        </single-row>
      </assert>
    </test>
    <test name="'rows are unique" uid="0060">
      <system-under-test>
        <resultSet file="..\Csv\ResellerOrderCountByYearBefore2006.csv"/>
      </system-under-test>
      <assert>
        <unique-rows/>
      </assert>
    </test>
    <test name="return 4 rows" uid="00070">
      <system-under-test>
        <result-set file="..\Csv\ResellerOrderCountByYearBefore2006.csv"/>
      </system-under-test>
      <assert>
        <row-count>
          <equal>4</equal>
        </row-count>
      </assert>
    </test>
    <test name="references exist" uid="00080">
      <system-under-test>
        <resultSet file="..\Csv\Orders.csv"/>
      </system-under-test>
      <assert>
        <lookup-exists>
          <join>
            <mapping candidate="#2" reference="#0" type="text"/>
          </join>
          <result-set>
            <query connection-string="@ref1">select 'CUST0001' union all select 'CUST0002' union all select 'CUST0003'</query>
          </result-set>
        </lookup-exists>
      </assert>
    </test>
    <test name="lookup-exist" uid="00081">
      <system-under-test>
        <result-set file="..\Csv\Orders.csv"/>
      </system-under-test>
      <assert>
        <lookup-exists>
          <join>
            <mapping candidate="#2" reference="#0" type="text"/>
          </join>
          <resultSet>
            <query>select 'CUST0001' union all select 'CUST0002' union all select 'CUST0003'</query>
          </resultSet>
        </lookup-exists>
      </assert>
    </test>
    <test name="lookup-exist with using" uid="00082">
      <system-under-test>
        <resultSet file="..\Csv\Orders.csv"/>
      </system-under-test>
      <assert>
        <lookup-exists>
          <join>
            <using type="text">#2</using>
          </join>
          <resultSet>
            <query>select 'Foo', 'A', 'CUST0001' union all select 'Foo', 'A', 'CUST0002' union all select 'Bar', 'B', 'CUST0003'</query>
          </resultSet>
        </lookup-exists>
      </assert>
    </test>
    <test name="lookup-exist reversed" uid="00081">
      <system-under-test>
        <result-set>
          <query>select 'CUST0001' union all select 'CUST0002' union all select 'CUST0003' union all select 'NOT EXISTING'</query>
        </result-set>
      </system-under-test>
      <assert>
        <lookup-exists reverse="true">
          <join>
            <mapping candidate="#2" reference="#0" type="text"/>
          </join>
          <result-set file="..\Csv\Orders.csv"/>
        </lookup-exists>
      </assert>
    </test>
    <test name="lookup-matches" uid="00091">
      <system-under-test>
        <result-set>
          <query>
            select
            NationalIdNumber,
            h.[DepartmentID]as DepartmentID,
            d.Name as DepartmentName
            from
            [HumanResources].[Employee] e
            inner join [HumanResources].[EmployeeDepartmentHistory]
            h on e.BusinessEntityId = h.BusinessEntityId
            inner join [HumanResources].[Department] d on
            h.DepartmentId = d.DepartmentId
          </query>
        </result-set>
      </system-under-test>
      <assert>
        <lookup-matches>
          <join>
            <mapping candidate="DepartmentID" reference="Id" type="numeric"/>
          </join>
          <inclusion>
            <mapping candidate="DepartmentName" reference="Name" type="text"/>
          </inclusion>
          <result-set>
            <query>
              select [DepartmentID] as Id, [Name] from [HumanResources].[Department]
            </query>
          </result-set>
        </lookup-matches>
      </assert>
    </test>
    <test name="lookup-matches with tolerances" uid="00092">
      <system-under-test>
        <result-set>
          <query>
            select
            NationalIdNumber,
            h.[DepartmentID]as DepartmentID,
            d.Name as DepartmentName
            from
            [HumanResources].[Employee] e
            inner join [HumanResources].[EmployeeDepartmentHistory]
            h on e.BusinessEntityId = h.BusinessEntityId
            inner join [HumanResources].[Department] d on
            h.DepartmentId = d.DepartmentId
          </query>
        </result-set>
      </system-under-test>
      <assert>
        <lookup-matches>
          <join>
            <mapping candidate="DepartmentID" reference="Id" type="numeric"/>
          </join>
          <inclusion>
            <mapping candidate="DepartmentName" reference="LowerName" type="text" tolerance="ignore-case"/>
          </inclusion>
          <result-set>
            <query>
              select [DepartmentID] as Id, Lower([Name]) as LowerName from [HumanResources].[Department]
            </query>
          </result-set>
        </lookup-matches>
      </assert>
    </test>
    <test name="Equality with new result-set" uid="00092">
      <system-under-test>
        <result-set>
          <row>
            <cell>A</cell>
            <cell>110</cell>
          </row>
          <row>
            <cell>B</cell>
            <cell>120</cell>
          </row>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to>
          <result-set>
            <query>
              select 'A', 110 union all select 'B', 120
            </query>
          </result-set>
        </equal-to>
      </assert>
    </test>
  </group>
  <group name="system-under-tests">
    <test name="Embedded result-set" uid="0101">
      <system-under-test>
        <resultSet>
          <row>
            <cell>CY 2005</cell>
            <cell>366</cell>
          </row>
          <row>
            <cell>CY 2006</cell>
            <cell>1015</cell>
          </row>
          <row>
            <cell>CY 2007</cell>
            <cell>1521</cell>
          </row>
          <row>
            <cell>CY 2008</cell>
            <cell>894</cell>
          </row>
        </resultSet>
      </system-under-test>
      <assert>
        <unique-rows/>
      </assert>
    </test>
    <test name="External result-set" uid="0102">
      <system-under-test>
        <resultSet file="..\Csv\ResellerOrderCountByYearBefore2006.csv"/>
      </system-under-test>
      <assert>
        <unique-rows/>
      </assert>
    </test>
    <test name="External result-set defined with variable formatting" uid="0103">
      <system-under-test>
        <resultSet file="~..\Csv\ResellerOrderCountByYearBefore{@year:yyyy}.csv"/>
      </system-under-test>
      <assert>
        <unique-rows/>
      </assert>
    </test>
    <test name="External result-set with if-missing" uid="0103">
      <system-under-test>
        <result-set>
          <file>
            <path>~..\Csv\ResellerOrderCountByYearBefore{@year:yy}.csv</path>
            <if-missing>
              <file>
                <path>..\Csv\ResellerOrderCountByYearBefore2006.csv</path>
              </file>
            </if-missing>
          </file>
        </result-set>
      </system-under-test>
      <assert>
        <unique-rows/>
      </assert>
    </test>
    <test name="Embedded query" uid="0104">
      <system-under-test>
        <resultSet>
          <query>
            select @prefix + ' 2005' as [year], 366 as [value]
            union all select @prefix + ' 2006' as [year], 1015 as [value]
            union all select @prefix + ' 2007' as [year], 1521 as [value]
            union all select @prefix + ' 2008' as [year], 894 as [value]
            <parameter name="prefix">CY</parameter>
          </query>
        </resultSet>
      </system-under-test>
      <assert>
        <all-rows>
          <predicate name="#0" type="text">
            <starts-with>CY </starts-with>
          </predicate>
        </all-rows>
      </assert>
    </test>
    <test name="External query" uid="0105">
      <system-under-test>
        <resultSet>
          <query file="..\Query\ResellerOrderCount.sql">
            <parameter name="prefix">CY</parameter>
          </query>
        </resultSet>
      </system-under-test>
      <assert>
        <all-rows>
          <predicate name="#0" type="text">
            <starts-with>CY </starts-with>
          </predicate>
        </all-rows>
      </assert>
    </test>
    <test name="Query from assembly" uid="0106">
      <system-under-test>
        <resultSet>
          <query>
            <assembly path="..\..\..\NBi.Testing.dll" class="NBi.Testing.Acceptance.Resources.AssemblyClass" method="GetTextSelectSql">
              <method-parameter name="prefix">CY</method-parameter>
            </assembly>
          </query>
        </resultSet>
      </system-under-test>
      <assert>
        <equalTo>
          <resultSet file="..\Csv\ResellerOrderCountByYearBefore2006.csv"/>
        </equalTo>
      </assert>
    </test>
    <test name="Query from report" uid="0107">
      <condition>
        <service-running name="MSSQL$SQL2017"/>
      </condition>
      <system-under-test>
        <resultSet>
          <query>
            <report source="Data Source=(local)\SQL2017;Initial Catalog=ReportServer;Integrated Security=True;"
                path="/AdventureWorks 2012/"
                name="Store_Contacts"
                dataset="Stores"
				    />
          </query>
        </resultSet>
      </system-under-test>
      <assert>
        <equalTo values-default-type="text">
          <resultSet file="..\Csv\BusinessEntity.csv"/>
        </equalTo>
      </assert>
    </test>
    <test name="Query with variable" uid="0108">
      <system-under-test>
        <resultSet>
          <query>
            select LoginID, JobTitle from [HumanResources].[Employee] where year([BirthDate])=@maxid
            <parameter name="maxid">@var1</parameter>
          </query>
        </resultSet>
      </system-under-test>
      <assert>
        <equalTo values-default-type="text">
          <resultSet>
            <row>
              <cell>adventure-works\ken0</cell>
              <cell>Chief Executive Officer</cell>
            </row>
            <row>
              <cell>adventure-works\belinda0</cell>
              <cell>Production Technician - WC45</cell>
            </row>
            <row>
              <cell>adventure-works\michael9</cell>
              <cell>Sales Representative</cell>
            </row>
          </resultSet>
        </equalTo>
      </assert>
    </test>
    <test name="Result-set is the cartesian product of two sequences" uid="0130">
      <system-under-test>
        <result-set>
          <sequences-combination operation="cartesian-product">
            <sequence type="text">
              <item>be</item>
              <item>fr</item>
            </sequence>
            <sequence type="dateTime">
              <loop-sentinel seed="2015-01-01" terminal="2017-01-01" step="1 year"/>
            </sequence>
          </sequences-combination>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to>
          <column index="0" role="key" type="text"/>
          <column index="1" role="key" type="dateTime"/>
          <resultSet>
            <row>
              <cell>be</cell>
              <cell>2015-01-01</cell>
            </row>
            <row>
              <cell>fr</cell>
              <cell>2015-01-01</cell>
            </row>
            <row>
              <cell>be</cell>
              <cell>2016-01-01</cell>
            </row>
            <row>
              <cell>fr</cell>
              <cell>2016-01-01</cell>
            </row>
            <row>
              <cell>be</cell>
              <cell>2017-01-01</cell>
            </row>
            <row>
              <cell>fr</cell>
              <cell>2017-01-01</cell>
            </row>
          </resultSet>
        </equal-to>
      </assert>
    </test>
    <test name="Result-set is the cartesian product of two sequences" uid="0130">
      <system-under-test>
        <result-set>
          <sequence type="text">
            <item>be</item>
            <item>fr</item>
          </sequence>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to>
          <column index="0" role="key" type="text"/>
          <result-set>
            <row>
              <cell>be</cell>
            </row>
            <row>
              <cell>fr</cell>
            </row>
          </result-set>
        </equal-to>
      </assert>
    </test>
  </group>
  <group name="alterations">
    <test name="Filter with one predicate" uid="0201">
      <system-under-test>
        <resultSet file="..\Csv\ResellerOrderCountByYearBefore2006.csv">
          <alteration>
            <filter>
              <predicate name="#0" type="text">
                <less-than>CY 2007</less-than>
              </predicate>
            </filter>
          </alteration>
        </resultSet>
      </system-under-test>
      <assert>
        <equalTo>
          <resultSet>
            <row>
              <cell>CY 2005</cell>
              <cell>366</cell>
            </row>
            <row>
              <cell>CY 2006</cell>
              <cell>1015</cell>
            </row>
          </resultSet>
        </equalTo>
      </assert>
    </test>
    <test name="Filter with two predicates" uid="0202">
      <system-under-test>
        <resultSet file="..\Csv\ResellerOrderCountByYearBefore2006.csv">
          <alteration>
            <filter>
              <combination operator="or">
                <predicate name="#0" type="text">
                  <less-than>CY 2007</less-than>
                </predicate>
                <predicate name="#1" type="numeric">
                  <more-than>1500</more-than>
                </predicate>
              </combination>
            </filter>
          </alteration>
        </resultSet>
      </system-under-test>
      <assert>
        <equalTo>
          <resultSet>
            <row>
              <cell>CY 2005</cell>
              <cell>366</cell>
            </row>
            <row>
              <cell>CY 2006</cell>
              <cell>1015</cell>
            </row>
            <row>
              <cell>CY 2007</cell>
              <cell>1521</cell>
            </row>
          </resultSet>
        </equalTo>
      </assert>
    </test>
    <test name="Filter with one predicate (but in a combination)" uid="0203">
      <system-under-test>
        <resultSet file="..\Csv\ResellerOrderCountByYearBefore2006.csv">
          <alteration>
            <filter>
              <combination operator="or">
                <predicate name="#0" type="text">
                  <less-than>CY 2007</less-than>
                </predicate>
              </combination>
            </filter>
          </alteration>
        </resultSet>
      </system-under-test>
      <assert>
        <equalTo>
          <resultSet>
            <row>
              <cell>CY 2005</cell>
              <cell>366</cell>
            </row>
            <row>
              <cell>CY 2006</cell>
              <cell>1015</cell>
            </row>
          </resultSet>
        </equalTo>
      </assert>
    </test>
    <test name="Filter with one predicate and a reference variable" uid="0204">
      <system-under-test>
        <resultSet file="..\Csv\ResellerOrderCountByYearBefore2006.csv">
          <alteration>
            <filter>
              <predicate name="#0" type="text">
                <less-than>@CY2007</less-than>
              </predicate>
            </filter>
          </alteration>
        </resultSet>
      </system-under-test>
      <assert>
        <equalTo>
          <resultSet>
            <row>
              <cell>CY 2005</cell>
              <cell>366</cell>
            </row>
            <row>
              <cell>CY 2006</cell>
              <cell>1015</cell>
            </row>
          </resultSet>
        </equalTo>
      </assert>
    </test>
    <test name="Filter with one predicate having the reference defined as a native transformation applied to a variable" uid="0205">
      <system-under-test>
        <resultSet file="..\Csv\ResellerOrderCountByYearBefore2006.csv">
          <alteration>
            <filter>
              <predicate name="#0" type="text">
                <less-than>@CY2007 | text-to-upper</less-than>
              </predicate>
            </filter>
          </alteration>
        </resultSet>
      </system-under-test>
      <assert>
        <equalTo>
          <resultSet>
            <row>
              <cell>CY 2005</cell>
              <cell>366</cell>
            </row>
            <row>
              <cell>CY 2006</cell>
              <cell>1015</cell>
            </row>
          </resultSet>
        </equalTo>
      </assert>
    </test>
    <test name="Filter with one predicate having the reference defined based on the context of the row" uid="0206">
      <system-under-test>
        <resultSet file="..\Csv\ResellerOrderCountByYearBefore2006bis.csv">
          <alteration>
            <filter>
              <predicate name="#1" type="numeric">
                <less-than>#2</less-than>
              </predicate>
            </filter>
            <project-away>
              <column identifier="#2"/>
            </project-away>
          </alteration>
        </resultSet>
      </system-under-test>
      <assert>
        <equalTo>
          <resultSet>
            <row>
              <cell>CY 2005</cell>
              <cell>366</cell>
            </row>
            <row>
              <cell>CY 2008</cell>
              <cell>894</cell>
            </row>
          </resultSet>
        </equalTo>
      </assert>
    </test>
    <test name="Filter with one predicate having the reference defined based on the context of the row and a native function" uid="0206">
      <system-under-test>
        <result-set file="..\Csv\ResellerOrderCountByYearBefore2006bis.csv">
          <alteration>
            <rename identifier="#2" new-name="myColumn"/>
            <filter>
              <predicate name="#1" type="numeric">
                <less-than>[myColumn] | numeric-to-increment</less-than>
              </predicate>
            </filter>
            <project-away>
              <column identifier="#2"/>
            </project-away>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to>
          <result-set>
            <row>
              <cell>CY 2005</cell>
              <cell>366</cell>
            </row>
            <row>
              <cell>CY 2008</cell>
              <cell>894</cell>
            </row>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Filter with one ranking top" uid="0211">
      <system-under-test>
        <resultSet file="..\Csv\ResellerOrderCountByYearBefore2006.csv">
          <alteration>
            <filter>
              <ranking operand="#1">
                <top count="2"/>
              </ranking>
            </filter>
          </alteration>
        </resultSet>
      </system-under-test>
      <assert>
        <all-rows>
          <predicate operand="#1">
            <more-than>1000</more-than>
          </predicate>
        </all-rows>
      </assert>
    </test>
    <test name="Filter with one ranking bottom" uid="0212">
      <system-under-test>
        <resultSet file="..\Csv\Orders.csv">
          <alteration>
            <filter>
              <ranking operand="#3">
                <bottom/>
                <group-by>
                  <column identifier="#2" type="text"/>
                </group-by>
              </ranking>
            </filter>
          </alteration>
        </resultSet>
      </system-under-test>
      <assert>
        <all-rows>
          <predicate operand="#0">
            <more-than>1</more-than>
          </predicate>
        </all-rows>
      </assert>
    </test>
    <test name="Conversion with text-to-date" uid="0221">
      <system-under-test>
        <resultSet file="..\Csv\Orders.csv">
          <alteration>
            <convert column="#1">
              <text-to-date culture="fr-fr" default-value="2016-01-01"/>
            </convert>
          </alteration>
        </resultSet>
      </system-under-test>
      <assert>
        <equalTo keys="first">
          <column index="0" role="key" type="numeric"/>
          <column index="1" role="value" type="dateTime"/>
          <column index="2" role="value" type="text"/>
          <resultSet>
            <row>
              <cell>1</cell>
              <cell>2017-07-06</cell>
              <cell>CUST0001</cell>
              <cell>100</cell>
            </row>
            <row>
              <cell>2</cell>
              <cell>2017-07-17</cell>
              <cell>CUST0001</cell>
              <cell>80</cell>
            </row>
            <row>
              <cell>3</cell>
              <cell>2017-01-08</cell>
              <cell>CUST0002</cell>
              <cell>120</cell>
            </row>
            <row>
              <cell>4</cell>
              <cell>2016-01-01</cell>
              <cell>CUST0002</cell>
              <cell>80</cell>
            </row>
            <row>
              <cell>5</cell>
              <cell>2017-12-18</cell>
              <cell>CUST0003</cell>
              <cell>55</cell>
            </row>
          </resultSet>
        </equalTo>
      </assert>
    </test>
    <test name="Conversion with text-to-date previously filtered by matches-date" uid="0222">
      <system-under-test>
        <resultSet file="..\Csv\Orders.csv">
          <alteration>
            <filter>
              <predicate operand="#1" type="text">
                <matches-date culture="fr-fr"/>
              </predicate>
            </filter>
            <convert column="#1">
              <text-to-date culture="fr-fr"/>
            </convert>
          </alteration>
        </resultSet>
      </system-under-test>
      <assert>
        <equalTo keys="first">
          <column index="0" role="key" type="numeric"/>
          <column index="1" role="value" type="dateTime"/>
          <column index="2" role="value" type="text"/>
          <resultSet>
            <row>
              <cell>1</cell>
              <cell>2017-07-06</cell>
              <cell>CUST0001</cell>
              <cell>100</cell>
            </row>
            <row>
              <cell>2</cell>
              <cell>2017-07-17</cell>
              <cell>CUST0001</cell>
              <cell>80</cell>
            </row>
            <row>
              <cell>3</cell>
              <cell>2017-01-08</cell>
              <cell>CUST0002</cell>
              <cell>120</cell>
            </row>
            <row>
              <cell>5</cell>
              <cell>2017-12-18</cell>
              <cell>CUST0003</cell>
              <cell>55</cell>
            </row>
          </resultSet>
        </equalTo>
      </assert>
    </test>
    <test name="Transformations with C#" uid="0230">
      <system-under-test>
        <resultSet file="..\Csv\Orders.csv">
          <alteration>
            <transform column-index="0" language="c-sharp" original-type="text">
              "AA" + value;
            </transform>
            <transform column-index="1" language="c-sharp" original-type="text">
              value.Substring(value.Length - 4);
            </transform>
            <transform column-index="2" language="c-sharp" original-type="text">
              value.Substring(value.LastIndexOf("0")+1)
            </transform>
          </alteration>
        </resultSet>
      </system-under-test>
      <assert>
        <equalTo keys="all-except-last">
          <resultSet>
            <row>
              <cell>AA0001</cell>
              <cell>2017</cell>
              <cell>1</cell>
              <cell>100</cell>
            </row>
            <row>
              <cell>AA0002</cell>
              <cell>2017</cell>
              <cell>1</cell>
              <cell>80</cell>
            </row>
            <row>
              <cell>AA0003</cell>
              <cell>2017</cell>
              <cell>2</cell>
              <cell>120</cell>
            </row>
            <row>
              <cell>AA0004</cell>
              <cell>2017</cell>
              <cell>2</cell>
              <cell>80</cell>
            </row>
            <row>
              <cell>AA0005</cell>
              <cell>2017</cell>
              <cell>3</cell>
              <cell>55</cell>
            </row>
          </resultSet>
        </equalTo>
      </assert>
    </test>
    <test name="Transformations with native functions" uid="0231">
      <system-under-test>
        <resultSet>
          <query>
            select 'a', 'FOO' union all select 'B', 'bar'
          </query>
          <alteration>
            <transform column-index="0" language="native" original-type="text">
              text-to-upper
            </transform>
          </alteration>
        </resultSet>
      </system-under-test>
      <assert>
        <equalTo keys="first">
          <column index="0" type="text" role="key">
            <transform language="native" original-type="text">text-to-upper</transform>
          </column>
          <column index="1" type="text" role="value" tolerance="ignore-case"/>
          <resultSet>
            <row>
              <cell>A</cell>
              <cell>foo</cell>
            </row>
            <row>
              <cell>b</cell>
              <cell>BaR</cell>
            </row>
          </resultSet>
        </equalTo>
      </assert>
    </test>
    <test name="Chaining native transformations in one transform statement" uid="0232">
      <system-under-test>
        <result-set>
          <query>
            select 'A', 'FOO' union all select 'B', 'bar' union all select 'C', null
          </query>
          <alteration>
            <transform column-index="1" language="native" original-type="text">
              null-to-empty | text-to-upper
            </transform>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equalTo keys="first">
          <column index="1" type="text" role="value">
            <transform language="native" original-type="text">null-to-empty | text-to-upper</transform>
          </column>
          <result-set>
            <row>
              <cell>A</cell>
              <cell>FOO</cell>
            </row>
            <row>
              <cell>B</cell>
              <cell>BAR</cell>
            </row>
            <row>
              <cell>C</cell>
              <cell>(empty)</cell>
            </row>
          </result-set>
        </equalTo>
      </assert>
    </test>
    <test name="Native transformations using variables" uid="0233">
      <system-under-test>
        <result-set>
          <query>
            select 'ABCDE', 'foo' 
            union all select 'bcdef', 'bar' 
            union all select null, ''
          </query>
          <alteration>
            <transform column-index="0" language="native" original-type="text">
              null-to-empty | text-to-upper | text-to-first-chars(2) | text-to-pad-right(@length, *)
            </transform>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to values-default-type="text">
          <column index="0" type="text" role="key" />
          <result-set>
            <row>
              <cell>ab*</cell>
              <cell>foo</cell>
            </row>
            <row>
              <cell>BC*</cell>
              <cell>bar</cell>
            </row>
            <row>
              <cell>(empty)</cell>
              <cell>(empty)</cell>
            </row>
            <alteration>
              <transform column-index="0" language="native" original-type="text">
                text-to-upper| text-to-pad-right(@length, *)
              </transform>
            </alteration>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Native transformations using row context" uid="0234">
      <system-under-test>
        <result-set>
          <query>
            select 'ABCDE', 'foo', 3, '*'
            union all select 'bc', 'bar', 4, '#'
            union all select null, '', 2, '*'
          </query>
          <alteration>
            <transform column-index="0" language="native" original-type="text">
              null-to-empty | text-to-upper | text-to-first-chars(#2) | text-to-pad-right(#2, #3)
            </transform>
            <project-away>
              <column identifier="#2"/>
              <column identifier="#3"/>
            </project-away>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to values-default-type="text">
          <column index="0" type="text" role="key" />
          <result-set>
            <row>
              <cell>abc</cell>
              <cell>foo</cell>
            </row>
            <row>
              <cell>bc##</cell>
              <cell>bar</cell>
            </row>
            <row>
              <cell>(empty)</cell>
              <cell>(empty)</cell>
            </row>
            <alteration>
              <transform column-index="0" language="native" original-type="text">
                text-to-upper| text-to-pad-right(2, *)
              </transform>
            </alteration>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Renamings" uid="0241">
      <system-under-test>
        <result-set>
          <query>
            select 'a' as f0, null as f1, 'FOO' as f2 union all select 'B', 'qwarks', 'bar'
          </query>
          <alteration>
            <rename identifier="[f0]" new-name="keyField"/>
            <rename identifier="[f2]" new-name="@CY2007"/>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to>
          <column name="keyField" role="key" type="text"/>
          <column name="CY 2007" role="value" type="text"/>
          <result-set>
            <query connection-string="@ref1">
              select 'a' as f0, 'FOO' as f1, null as f2 union all select 'B', 'bar', null
            </query>
            <alteration>
              <rename identifier="[f0]" new-name="keyField"/>
              <rename identifier="[f1]" new-name="@CY2007"/>
            </alteration>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Renamings with non-existing columns" uid="0242">
      <system-under-test>
        <result-set>
          <query>
            select 'a' as f0, null as f2, 'FOO' as f1 union all select 'B', 'qwarks', 'bar'
          </query>
          <alteration>
            <rename identifier="[f0]" new-name="keyField"/>
            <rename identifier="[f17]" new-name="foo">
              <missing behavior="skip" />
            </rename>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to>
          <column name="keyField" role="key" type="text"/>
          <column name="f1" role="value" type="text"/>
          <result-set>
            <query connection-string="@ref1">
              select 'a' as f0, 'FOO' as f1, null as f2 union all select 'B', 'bar', null
            </query>
            <alteration>
              <rename identifier="[f0]" new-name="keyField"/>
              <rename identifier="[f17]" new-name="foo">
                <missing behavior="skip" />
              </rename>
            </alteration>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Extensions" uid="0251">
      <system-under-test>
        <result-set>
          <query>
            select 'A' as Id, 10 as ColA, 20 as ColB union all select 'B', 30, 50
          </query>
          <alteration>
            <extend identifier="[Sum]">
              <script language="ncalc">ColA + ColB</script>
            </extend>
            <extend identifier="[Product]">
              <script language="ncalc">ColA * ColB</script>
            </extend>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to>
          <result-set>
            <row>
              <cell>A</cell>
              <cell>10</cell>
              <cell>30</cell>
              <cell>200</cell>
            </row>
            <row>
              <cell>B</cell>
              <cell>30</cell>
              <cell>80</cell>
              <cell>1500</cell>
            </row>
            <alteration>
              <extend identifier="#2">
                <script language="ncalc">[#3] - [#1]</script>
              </extend>
            </alteration>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Extensions based on row context" uid="0252">
      <system-under-test>
        <result-set>
          <query>
            select '2019-10-07 22:00:00' as Timing, 0 as Shift, 100 as ValueCol
            union all select '2019-10-07 22:00:00' as Timing, 1 as Shift, 120 as ValueCol
          </query>
          <alteration>
            <extend identifier="[NewTime]">
              <script language="native">[Timing] | dateTime-to-add(01:00:00, [Shift])</script>
            </extend>
            <project>
              <column identifier="[NewTime]"/>
              <column identifier="[ValueCol]"/>
            </project>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to>
          <column index="0" role="key" type="dateTime"/>
          <result-set>
            <row>
              <cell>2019-10-07 22:00:00</cell>
              <cell>50</cell>
              <cell>2</cell>
            </row>
            <row>
              <cell>2019-10-07 23:00:00</cell>
              <cell>40</cell>
              <cell>3</cell>
            </row>
            <alteration>
              <extend identifier="[NewValue]">
                <script language="native">#1 | numeric-to-multiply(#2)</script>
              </extend>
              <project-away>
                <column identifier="#1"/>
                <column identifier="#2"/>
              </project-away>
            </alteration>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Summarization on all columns" uid="0261">
      <system-under-test>
        <result-set>
          <query>
            select 'A' as Key1, 'alpha' as Key2, 10 as Value
            union all select 'B', 'alpha', 30
            union all select 'B', 'alpha', 20
            union all select 'B', 'beta', 10
            union all select 'A', 'beta', 15
          </query>
          <alteration>
            <summarize>
              <sum column="[Value]" type="numeric"/>
              <group-by>
                <column identifier="Key1" type="text"/>
                <column identifier="Key2" type="text"/>
              </group-by>
            </summarize>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to keys="all-except-last">
          <result-set>
            <row>
              <cell>A</cell>
              <cell>alpha</cell>
              <cell>10</cell>
            </row>
            <row>
              <cell>A</cell>
              <cell>beta</cell>
              <cell>15</cell>
            </row>
            <row>
              <cell>B</cell>
              <cell>alpha</cell>
              <cell>50</cell>
            </row>
            <row>
              <cell>B</cell>
              <cell>beta</cell>
              <cell>10</cell>
            </row>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Summarization on few columns" uid="0262">
      <system-under-test>
        <result-set>
          <query>
            select 'A' as Key1, 'alpha' as Key2, 10 as Value
            union all select 'B', 'alpha', 30
            union all select 'B', 'alpha', 20
            union all select 'B', 'beta', 10
            union all select 'A', 'beta', 15
          </query>
          <alteration>
            <summarize>
              <sum column="[Value]" type="numeric"/>
              <group-by>
                <column identifier="Key1" type="text"/>
              </group-by>
            </summarize>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to>
          <result-set>
            <row>
              <cell>A</cell>
              <cell>25</cell>
            </row>
            <row>
              <cell>B</cell>
              <cell>60</cell>
            </row>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Summarization on no column" uid="0263">
      <system-under-test>
        <result-set>
          <query>
            select 'A' as Key1, 'alpha' as Key2, 10 as Value
            union all select 'B', 'alpha', 30
            union all select 'B', 'alpha', 20
            union all select 'B', 'beta', 10
            union all select 'A', 'beta', 15
          </query>
          <alteration>
            <summarize>
              <sum column="[Value]" type="numeric"/>
            </summarize>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to behavior="single-row">
          <result-set>
            <row>
              <cell>85</cell>
            </row>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Chaining two summarizations" uid="0264">
      <system-under-test>
        <result-set>
          <query>
            select 'A' as Key1, '2019-01-01' as Key2, 10 as Value
            union all select 'B', '2019-01-01', 30
            union all select 'B', '2019-01-01', 20
            union all select 'B', '2018-01-01', 10
            union all select 'A', '2018-01-01', 15
          </query>
          <alteration>
            <summarize>
              <average column="[Value]" type="numeric"/>
              <group-by>
                <column identifier="Key2" type="text"/>
                <column identifier="Key1" type="text"/>
              </group-by>
            </summarize>
            <summarize>
              <sum column="[Value]" type="numeric"/>
              <group-by>
                <column identifier="Key1" type="text"/>
              </group-by>
            </summarize>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to>
          <result-set>
            <row>
              <cell>A</cell>
              <cell>25</cell>
            </row>
            <row>
              <cell>B</cell>
              <cell>35</cell>
            </row>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Complex chaining two summarizations" uid="0264">
      <system-under-test>
        <result-set>
          <query>
            select 'EAN1' as Ean, '2019-01-01 00:00:00' as UtcDateTime, 3 as Value, 'Wind Turbine - Off Shore' as ProductionType
            union all select 'EAN1' as Ean, '2019-01-01 00:30:00' as UtcDateTime, 4 as Value   , 'Wind Turbine - Off Shore' as ProductionType
            union all select 'EAN1' as Ean, '2019-01-01 01:00:00' as UtcDateTime, 10 as Value  , 'Wind Turbine - Off Shore' as ProductionType
            union all select 'EAN1' as Ean, '2019-01-01 01:30:00' as UtcDateTime, 20 as Value  , 'Wind Turbine - Off Shore' as ProductionType
            union all select 'EAN2' as Ean, '2019-01-01 00:00:00' as UtcDateTime, 6 as Value   , 'Wind Turbine - Off Shore' as ProductionType
            union all select 'EAN2' as Ean, '2019-01-01 00:30:00' as UtcDateTime, 8 as Value   , 'Wind Turbine - Off Shore' as ProductionType
            union all select 'EAN2' as Ean, '2019-01-01 01:00:00' as UtcDateTime, 10 as Value  , 'Wind Turbine - Off Shore' as ProductionType
            union all select 'EAN2' as Ean, '2019-01-01 01:30:00' as UtcDateTime, 14 as Value  , 'Wind Turbine - Off Shore' as ProductionType
          </query>
          <alteration>
            <transform language="native" original-type="dateTime" column="UtcDateTime">
              dateTime-to-floor-hour
            </transform>
            <summarize>
              <average column="[Value]" type="numeric"/>
              <group-by>
                <column identifier="Ean" type="text"/>
                <column identifier="UtcDateTime" type="dateTime"/>
                <column identifier="ProductionType" type="text"/>
              </group-by>
            </summarize>
            <summarize>
              <sum column="[Value]" type="numeric"/>
              <group-by>
                <column identifier="ProductionType" type="text"/>
                <column identifier="UtcDateTime" type="dateTime"/>
              </group-by>
            </summarize>
            <extend identifier="ActualGenerationOutput">
              <script language="ncalc">
                Round(Abs(Value), 0)
              </script>
            </extend>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to>
          <column name="UtcDateTime" role="key" type="dateTime" />
          <column name="[ActualGenerationOutput]" role="value" type="numeric" tolerance="0.00" />
          <result-set>
            <row>
              <cell>Wind Turbine - Off Shore</cell>
              <cell>2019-01-01 00:00:00</cell>
              <cell>10</cell>
            </row>
            <row>
              <cell>Wind Turbine - Off Shore</cell>
              <cell>2019-01-01 01:00:00</cell>
              <cell>27</cell>
            </row>
            <alteration>
              <rename identifier="#1" new-name="UtcDateTime"/>
              <rename identifier="#2" new-name="ActualGenerationOutput"/>
            </alteration>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Unstacking on one key" uid="0270">
      <system-under-test>
        <result-set>
          <query>
            select 'A' as Key1, 'alpha' as Header, 10 as Value
            union all select 'B', 'beta', 10
            union all select 'A', 'beta', 15
          </query>
          <alteration>
            <unstack>
              <header>
                <column identifier="Header"/>
              </header>
              <group-by>
                <column identifier="#0"/>
              </group-by>
            </unstack>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to keys="first">
          <result-set>
            <row>
              <cell>A</cell>
              <cell>10</cell>
              <cell>15</cell>
            </row>
            <row>
              <cell>B</cell>
              <cell>(null)</cell>
              <cell>10</cell>
            </row>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Unstacking owith enforced-values" uid="0271">
      <system-under-test>
        <result-set>
          <query>
            select 'A' as Key1, 'alpha' as Header, 10 as Value
            union all select 'B', 'beta', 10
            union all select 'A', 'beta', 15
          </query>
          <alteration>
            <unstack>
              <header>
                <column identifier="Header"/>
                <enforced-value>alpha</enforced-value>
                <enforced-value>omega</enforced-value>
              </header>
              <group-by>
                <column identifier="#0"/>
              </group-by>
            </unstack>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to>
          <column name="Key1" role="key" type="text"/>
          <column name="alpha" role="value" type="numeric"/>
          <column name="omega" role="value" type="numeric"/>
          <result-set>
            <query>
              select 'A' as Key1, '10' as alpha, 15 as beta, null as omega
              union all select 'B' as Key1, null as alpha, 15 as beta, null as omega
            </query>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Project on two fields" uid="0280">
      <system-under-test>
        <result-set>
          <query>
            select 'A' as Col0, 'alpha' as Col1, 15 as Col2
            union all select 'B', 'beta', 10
          </query>
          <alteration>
            <project>
              <column identifier="#0"/>
              <column identifier="Col2"/>
            </project>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to keys="first">
          <result-set>
            <row>
              <cell>A</cell>
              <cell>15</cell>
            </row>
            <row>
              <cell>B</cell>
              <cell>10</cell>
            </row>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Project on two fields with re-order" uid="0281">
      <system-under-test>
        <result-set>
          <query>
            select 'A' as Col0, 'alpha' as Col1, 15 as Col2
            union all select 'B', 'beta', 10
          </query>
          <alteration>
            <project>
              <column identifier="Col2"/>
              <column identifier="#0"/>
            </project>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to>
          <column index="0" role="value" type="numeric"/>
          <column index="1" role="key" type="text"/>
          <result-set>
            <row>
              <cell>15</cell>
              <cell>A</cell>
            </row>
            <row>
              <cell>10</cell>
              <cell>B</cell>
            </row>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Project-away on two fields" uid="0282">
      <system-under-test>
        <result-set>
          <query>
            select 'A' as Col0, 'alpha' as Col1, 10 as Col2
            union all select 'B', 'beta', 10
          </query>
          <alteration>
            <project-away>
              <column identifier="Col2"/>
              <column identifier="#0"/>
            </project-away>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to keys="first">
          <result-set>
            <row>
              <cell>alpha</cell>
            </row>
            <row>
              <cell>beta</cell>
            </row>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Transformation lookup" uid="0290">
      <system-under-test>
        <resultSet>
          <query>
            select 'A' as Id, 1 as FooBarId  union all select 'B', 2 union all select 'C', 2 union all select 'D', 3
          </query>
          <alteration>
            <lookup-replace>
              <missing behavior="discard-row"/>
              <join>
                <using>[FooBarId]</using>
              </join>
              <result-set>
                <query connection-string="Data Source=mhknbn2kdz.database.windows.net;Initial Catalog=AdventureWorks2012;User Id=sqlfamily;password=sqlf@m1ly">
                  select 1 as FooBarId, 'Foo' as ValueX union all select 2, 'Bar'
                </query>
              </result-set>
              <replacement identifier="ValueX"/>
            </lookup-replace>
          </alteration>
        </resultSet>
      </system-under-test>
      <assert>
        <equal-to keys="first">
          <column index="0" type="text" role="key"/>
          <column index="1" type="text" role="value"/>
          <result-set>
            <row>
              <cell>A</cell>
              <cell>Foo</cell>
            </row>
            <row>
              <cell>B</cell>
              <cell>Bar</cell>
            </row>
            <row>
              <cell>C</cell>
              <cell>Bar</cell>
            </row>
          </result-set>
        </equal-to>
      </assert>
    </test>
    <test name="Transform, lookup-replace, summarize, unstack, extend, project" uid="0300">
      <system-under-test>
        <result-set>
          <query>
            select '2019-01-01 00:00:00' as DateTime, 'I' as Direction, 10 as Value
            union all select '2019-01-01 00:15:00', 'I', 20
            union all select '2019-01-01 00:30:00', 'I', 15
            union all select '2019-01-01 00:45:00', 'I', 15
            union all select '2019-01-01 00:00:00', 'E', 7
            union all select '2019-01-01 00:15:00', 'E', 8
            union all select '2019-01-01 00:30:00', 'E', 12
            union all select '2019-01-01 00:45:00', 'E', 13
            union all select '2019-01-01 01:00:00', 'I', 5
            union all select '2019-01-01 01:15:00', 'I', 15
            union all select '2019-01-01 01:30:00', 'I', 18
            union all select '2019-01-01 01:45:00', 'I', 17
            union all select '2019-01-01 01:00:00', 'E', 14
            union all select '2019-01-01 01:15:00', 'E', 16
            union all select '2019-01-01 01:30:00', 'E', 11
            union all select '2019-01-01 01:45:00', 'E', 19
          </query>
          <alteration>
            <transform column="DateTime" language="native" original-type="dateTime">
              dateTime-to-floor-hour
            </transform>
            <lookup-replace>
              <join>
                <mapping candidate="Direction" reference="#0"/>
              </join>
              <result-set>
                <row>
                  <cell>I</cell>
                  <cell>Import</cell>
                </row>
                <row>
                  <cell>E</cell>
                  <cell>Export</cell>
                </row>
              </result-set>
              <replacement identifier="#1"/>
            </lookup-replace>
            <summarize>
              <sum column="Value" type="numeric"/>
              <group-by>
                <column identifier="DateTime"/>
                <column identifier="Direction"/>
              </group-by>
            </summarize>
            <unstack>
              <header>
                <column identifier="Direction"/>
              </header>
              <group-by>
                <column identifier="DateTime"/>
              </group-by>
            </unstack>
            <extend identifier="Delta">
              <script language="ncalc">
                [Import] - [Export]
              </script>
            </extend>
            <project>
              <column identifier="DateTime"/>
              <column identifier="Delta"/>
            </project>
          </alteration>
        </result-set>
      </system-under-test>
      <assert>
        <equal-to keys="first">
          <column index="0" role="key" type="dateTime"/>
          <result-set>
            <row>
              <cell>2019-01-01 00:00:00</cell>
              <cell>20</cell>
            </row>
            <row>
              <cell>2019-01-01 01:00:00</cell>
              <cell>-5</cell>
            </row>
          </result-set>
        </equal-to>
      </assert>
    </test>
  </group>
</testSuite>